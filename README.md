## Java内存模型 - 同步八种操作
### lock(锁定)
作用于主内存的变量，把一个变量标识为一条线程独占状态

### unlock(解锁)
作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定

### read(读取)
作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用

### load(载入)
作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中

### use(使用)
作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎

### assign(赋值)
作用于工作内存的变量，它把一个从执行引擎接受到的值赋值给工作内存的变量

### store(存储)
作用于工作内存的变量，把一个内存中的一个变量的值传送到主内存中，以便随后的write的操作

### write(写入)
作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中

## Java内存模型 - 同步规则
如果要把一个变量从主内存中复制到工作内存，就需要按顺序地执行read和load操作，如果把变量从工作内存中同步回主内存中，就要按顺序地执行store和write操作。但Java内存模型只要求上述操作必须按照顺序执行，而没有保证必须是连续执行

不允许read和load，store和write操作之一单独出现

不允许一个线程丢弃它最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中

不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中

一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作

一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。lock和unlock必须成对出现。

如果一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值

如果一个变量事先没有被lock锁定操作，则不允许对它执行unlock操作，也不允许unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）

## 线程安全性
定义，当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些进程将如何交替执行，并且在主调代码中不需要任何额外的同步或协调，这个类都能表现出正确的行为，那么就称这个类是线程安全的

### 原子性
提供了互斥访问，同一时刻只能有一个线程来对它进行操作

### 可见性
一个线程对主内存的修改可以即时的被其他线程观察到

### 有序性
一个线程观察其它线程中的指令执行顺序，由于指令重排序的存在，该观察结果一般杂乱无序

## 原子性 - 锁
synchronized，依赖JVM
Lock，依赖特殊的cpu指令，代码实现，ReentranLock

## 原子性 - synchronized
修饰代码块，大括号括起来的代码，作用于调用的对象
修饰方法，整个方法，作用于调用的对象
修饰静态方法，整个静态方法，作用于所有对象
修饰类，括号括起来的部分，作用于所有对象

## 原子性 - 对比
synchronized，不可中断锁，适合竞争不激烈，可读性好
Lock，可中断锁，多样化同步，竞争激烈时能维持常态
Atomic，竞争激烈时能维持常态，比Lock性能好，只能同步一个值

## 导致共享变量在线程间不可见原因
线程交叉执行
重排序结合线程交叉执行
共享变量更新后的值没有在工作内存与主存间即时更新

## 可见性 - synchronized
JMM关于synchronized的两条规定
线程解锁前，必须把共享变量的最新值刷新到主内存
线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主存中重新读取最新的值（注意，加锁与解锁是同一把锁）

## 可见性 - volatile
通过加入内存屏障和禁止重排序优化来实现
对volatile变量写操作时，会在写操作后加入一条store屏障指令，将本地内存中的共享变量值刷新到主内存
对volatile变量读操作时，会在读操作前加入一条load屏障指令，从主内存中读取共享变量

## 有序性
Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性

## 有序性 - happens-before原则
程序次序规则，一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作
锁定规则，一个unLock操作先行发生于后面对同一个锁的lock操作
volatile变量规则，对一个变量的写操作先行发生于后面对这个变量的读操作
传递规则，如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C
线程启动原则，Thread对象的start()方法先行发生于此线程的每一个动作
线程中断规则，对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件发生
线程终结规则，线程中所有的操作都先发生于线程的终止检测，我们可以通过Thread.join()方法结束，Thread.isAlive()的返回值手段检测到线程已经终止执行
对象终结规则，一个对象的初始化完成先行发生于它的finalize()方法开始

## 发布对象
使一个对象能够被当前范围之外的代码所使用

## 对象溢出
一种错误的发布，当一个对象还没有构造完成时，就使它被其他线程所见

## 安全发布对象
在静态初始化函数中初始化一个对象的引用
将对象的引用保存到volatile类型域或者AtomicReference对象中
将对象的引用保存到某个正确构造对象的final类型域中
将对象的引用保存到一个由锁保护的域中

## 不可变对象
不可变对象需要满足的条件
对象创建以后其状态就不能修改
对象所有域都是final类型
对象是正确创建的（对象创建时间，this引用没有溢出）

## final关键字
修饰类：不能被继承
修饰方法：1、锁定方法不被继承类修改；2、效率（早期final修饰的方法会变成内嵌调用）
修饰变量：基本数据类型变量、引用类型变量

## 代替final
Collections.unmodifiableXXX：Collection、List、Set、Map...
Guava：ImmutableXXX：Collection、List、Set、Map...

## 线程封闭
Ad-hoc 线程封闭：程序控制实现，最糟糕，忽略
堆栈封闭：局部变量，无并发问题
ThreadLocal 线程封闭：特别好的封闭方法

## 线程不安全的类与写法
StringBuilder -> StringBuffer
SimpleDateFormat -> JodaTime
ArrayList, HashSet, HashMap 等Collections
先检查再执行：if (condition(a)) { handle(a);}

## 同步容器
ArrayList -> Vector, Stack
HashMap -> HashTable(key、value不能为null)
Collections.synchronizedXXX(List、Set、Map)

## 并发容器J.U.C（java.util.concurrent）
ArrayList -> CopyOnWriteArrayList
HashSet, TreeSet -> CopyOnWriteArraySet, ConcurrentSkipListSet
HashMap, TreeMap -> ConcurrentHashMap, ConcurrentSkipListMap

## 安全共享对象策略
线程限制：一个被线程限制的对象，由线程独占，并且只能被占有它的线程修改
共享只读：一个共享只读的对象，在没有额外同步的情况下，可以被多个线程并发访问，但是任何线程都不能修改它
线程安全对象：一个线程安全的对象或者容器，在内部通过同步机制来保证线程安全，所以其它线程无需额外的同步就可以通过公共接口随意访问它
被守护对象：被守护对象只能通过获取特定的锁来访问

## AbstractQueuedSynchronizer - AQS
使用Node实现FIFO对列，可以用于构建锁或者其它同步装置的基础框架
利用了一个int类型表示状态
使用方法是继承
子类通过继承并通过实现它的方法管理其状态{acquire 和 release }的方法操纵状态
可以同时实现排它锁和共享锁模式（独占、共享）

## AQS 同步组件
CountDownLatch (数值递减闭锁)：通过它可以完成类似于阻塞当前线程
Semaphore (信号量)：可以控制并发访问线程的个数
CyclicBarrier (循环屏障)：它允许一组线程相互等待，直到到达某个公共的屏障点，才继续执行后续的操作
ReentrantLock (可重入锁)：
Condition
FutureTask 

## ReentrantLock 独有功能
可指定是公平锁还是非公平锁
提供了一个Condition类，可以分组唤醒需要唤醒的线程
提供能够中断等待锁的线程机制，lock.lockInterruptibly()

## Fork/Join 框架
把大任务分成若干个子任务，合并子任务的结果，得到大任务的结果，应用的是工作窃取算法

## BlockingQueue (阻塞队列)

## 线程池
new Thread 弊端
每次new Thread 新建对象，性能差
线程缺乏统一管理，可能无限制的新建线程，互相竞争，有可能占用过多系统资源导致死机或OOM
缺少更多的功能，如更多执行、定期执行、线程中断

线程池的好处
重用存在的线程，减少对象创建、消亡的开销、性能佳
可有效控制最大并发线程数，提高系统资源利用率，同时可以避免过多资源竞争，避免阻塞
提供定时执行、定期执行、单线程、并发数控制等功能

## ThreadPoolExecutor
corePoolSize：核心线程数量
maximumPoolSize：线程最大线程数
workQueue：阻塞队列，储存等待执行的任务，很重要，会对线程池运行过程产生重大影响
keepAliveTime：线程没有任务执行时最多保持多久时间终止
unit：keepAliveTime的时间单位
threadFactory：线程工厂，用来创建线程
rejectHandler：当拒绝处理任务时的策略

execute()：提交任务，交给线程池执行
submit()：提交任务，能够返回执行结果 execute + Future
shutdown()：关闭线程池，等待任务都执行完
shutdownNow()：关闭线程池，不等待任务执行完

getTaskCount()：线程池已执行和未执行的任务总数
getCompletedTaskCount()：已完成的任务数量
getPoolSize()：线程池当前的线程数量
getActiveCount()：当前线程池中正在执行任务的线程数量

## 多线程并发最佳实践
使用本地变量
使用不可变类
最小化锁的作用域范围：S = 1/(1-a+a/n)
使用线程池的Executor，而不是直接new Thread执行
宁可使用同步也不要使用线程的wait和notify
使用Blocking Queue实现生产-消费模式
使用并发集合而不是加了锁的同步集合
使用Semaphore创建有界的访问
宁可使用同步代码块，也不使用同步的方法
避免使用静态变量
